# 查找

查找表是由同一类型的数据元素或记录构成的集合，由于“集合”中的数据元素之间的关系十分松散，因此查找表是一种非常灵便的数据结构。

## 查找的相关概念

我们称实现了 Find, Read, Insert, Delete 的查找表为动态查找表。而实现了 Find, Read 的查找表为静态查找表。

关键字，或者键，是数据元素中用来表示一个数据元素的值。  
若此关键字可以唯一地表示一个记录，我们称该关键字为主关键字。此即是说，对于不同的记录，它们的主关键字一定均不同。反之，称用以识别若干记录的关键字为次关键字。   
当数据元素只有一个数据项时，关键字就是元素本身的值。

查找，是根据给定的某个值，在查找表中确定一个其关键字等于其给定值的记录或数据元素。若表中存在这样一个元素，则查找成功，反之查找不成功。

查找方法的实现取决于查找表的结构，即表中数据元素是如何组织在一起的。组织方式的不同会对查找的效率起决定性影响。接下来我们会研究不同数据结构上不同算法的查找效率，并尽可能提高它。

## 查找的效率

可以使用平均查找长度(Average Search Lengthm, ASL)衡量不同查找算法的好坏。  
详细地说，平均查找长度是指为了确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。  

对于含有 n 个记录的表，查找成功时的平均查找长度为  
$ASL=\sum^n_{i=1}P_iC_i$  
其中，$P_i$ 为查找表中第 i 个记录的概率。$C_i$ 为找到表中其关键字与给定值相等的第 i 个记录时，和给定值已经进行过的比较的关键字的个数。

# 线性表

顺序表或者线性链表表示的静态查找表。表内元素之间是无序的。

```cpp
struct ElemType {
    KeyType key;
    ... // 其他信息
}
struct SStable {
    ElemType *elem;
    int length;
}
```

## 顺序查找

### 实现

这里不给出效率低的算法，而给出一种使用“哨兵”的高效算法。这种算法把待查关键字存入表头，在这种情况下，如果表中没有待查元素，则算法最终在哨兵处停下，并输出其下标 0。我们不需要检查 i 是否越界就能完成查找，这将带来可观的速度优化。

```cpp
int OrderSearch(SStable ST, KeyType key) {
    ST.elem[0].key = key;
    int i;
    for(i = ST.length; ST.elem[i].key != key; i--);
    return i;
}
```

### 效率

对于该实现，查找第 i 个元素需要比较 n - i + 1 次。查找失败需要比较 n + 1 次。

### $TimeComplexity=O(n)$  
### $SpaceComplexity=O(1)$  
### $ASL=\frac{1+n}{2}$

很多时候表中各个记录的查找概率并不相等，用户查找某些记录概率会多于其他记录的概率。  
如果能设法把查找概率高的记录放在靠近开始查找的位置，可以有效提高查找效率。  
然而，记录的查找概率很多时候难以理论推导或者提前测定。可以在记录中附设一个访问频度域，始终保持记录按非递增有序的次序排列，或者每次查找后均将刚查到的记录直接移至表头。

顺序查找是一种简单且对逻辑次序无要求的算法。但它的效率很低。

## 二分查找

### 实现

二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。在二分查找中，维护三个变量 lo，hi 和 mid。它们代表上界、下界、中点三个元素的下标。  
置 lo 为 1，置 hi 为表长，mid 为 (lo + hi) / 2。比较 mid 和 key 的大小关系。当它们相等，则函数返回 mid。如果 key < [mid]，则令 hi = mid - 1。如果 key > [mid]，则令 lo = mid + 1。如果出现了 hi < low 的情况，则说明查找失败。

该算法的迭代实现如下。

```cpp
int BinarySearch(SStable ST, KeyType key) {
    int lo = 1, hi = ST.length, mid;
    while(lo <= hi) {
        mid = (lo + hi) >> 1;
        if(key == ST.elem[mid].key) 
            return mid;
        else if(key < ST.elem[mid].key)
            hi = mid - 1;
        else if(key > ST.elem[mid].key)
            lo = mid + 1;
    }
    return 0;
}
```

该算法的递归实现如下。

```cpp
int BinarySearch(SStable ST, KeyType key, int lo, int hi) {
    if(lo > hi)
        return 0;
    mid = (lo + hi) >> 1;
    if(key == ST.elem[mid].key)
        return mid;
    else if(key < ST.elem[mid].key)
        return BinarySearch(ST, key, lo, mid - 1);
    else if(key > ST.elem[mid].key)
        return BinarySearch(ST, key, mid + 1, hi);
}
```

### 效率

我们可以用一个二叉树来描述二分查找的过程。这样的二叉树叫做判定树或决策树。

判定树的根结点应该是 (lo + hi) / 2。这是首先被比较的结点。然后，根结点的左孩子应该是 (lo + mid) / 2，结点的右孩子应该是 (mid + hi) / 2。以此类推。  
寻找某元素所需的比较次数等于该元素在判定树的深度，也等于从根结点到该结点的路径所经过的结点数。在最坏情况下，查找所需要的比较次数为 $\lfloor log_2n\rfloor+1$。  

设表长 $n=2^h-1$，深度 $h=log_2(n+1)$，每个记录的查找概率相等。

### $ASL=\sum_{i=1}^np_ic_i=\frac1n\sum ^n_{i=1}c_i\\=\frac1n\sum^h_{j=1}j2^{j-1}=\frac{n+1}nlog_2(n+1)-1$  

当 n 足够大时，可认为 $ASL=log_2(n+1)-1$。

折半查找法只适用于有序的顺序表，它于无序表或链表无效。

## 分块查找

分块查找是二分查找和顺序查找的改进。分块查找只要求索引表是有序的，对块内结点的序没有要求。分块查找的速度不如折半查找算法，但比顺序查找算法快得多，同时不需对全部节点进行排序。

当节点和块很多时，对索引表可以采用二分查找，这样能够进一步提高查找的速度。

分块查找将表分成了多块。对于第 i 块和第 j 块，若 i < j，则第 j 块中所有记录的关键字均大于第 i 块中的最大关键字。  
分块查找还建立了索引表。表中的每个块索引都含有最大关键字域和本块首结点的索引，且索引表按最大关键字有序。

### 效率

一般情况下，为了进行分块查找，可以将长度为 n 的表均匀分成 b 块，每块含有 s 个记录，即 $b=\lceil\frac{n}{s}\rceil$。我们还假定每个块的查找概率均为 $\frac1b$，每个记录的查找概率均为 $\frac1s$，用二分查找确定所在块。

### $ASL=L_b+l_w\thickapprox log_2(\frac{n}{s}+1)+\frac{s}2$

分块查找的插入和删除比较容易，无需进行大量改动。但是分块查找需要使用一个索引表，且需要对这个索引表进行排序运算。

# 树表

## 二叉排序树

二叉排序树(Binary Sort Tree, BST)又称二叉搜索树、二叉查找树。

二叉排序树或者是一棵空树，或者是满足下列性质的二叉树：
- 若其左子树非空，则左子树上所有结点的值均小于它的根结点的值。
- 若其右子树非空，则右子树上所有结点的值均大于等于它的根结点的值。
- 其左右子树也分别是二叉排序树。
