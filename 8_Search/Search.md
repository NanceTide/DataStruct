# 查找

查找表是由同一类型的数据元素或记录构成的集合，由于“集合”中的数据元素之间的关系十分松散，因此查找表是一种非常灵便的数据结构。

## 查找的相关概念

我们称实现了 Find, Read, Insert, Delete 的查找表为动态查找表。而实现了 Find, Read 的查找表为静态查找表。

关键字，或者键，是数据元素中用来表示一个数据元素的值。  
若此关键字可以唯一地表示一个记录，我们称该关键字为主关键字。此即是说，对于不同的记录，它们的主关键字一定均不同。反之，称用以识别若干记录的关键字为次关键字。   
当数据元素只有一个数据项时，关键字就是元素本身的值。

查找，是根据给定的某个值，在查找表中确定一个其关键字等于其给定值的记录或数据元素。若表中存在这样一个元素，则查找成功，反之查找不成功。

查找方法的实现取决于查找表的结构，即表中数据元素是如何组织在一起的。组织方式的不同会对查找的效率起决定性影响。接下来我们会研究不同数据结构上不同算法的查找效率，并尽可能提高它。

## 查找的效率

可以使用平均查找长度(Average Search Lengthm, ASL)衡量不同查找算法的好坏。  
详细地说，平均查找长度是指为了确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值。  

对于含有 n 个记录的表，查找成功时的平均查找长度为  
$ASL=\sum^n_{i=1}P_iC_i$  
其中，$P_i$ 为查找表中第 i 个记录的概率。$C_i$ 为找到表中其关键字与给定值相等的第 i 个记录时，和给定值已经进行过的比较的关键字的个数。

在很多实例中，表中各个记录的查找概率并不相等，用户查找某些记录概率会多于其他记录的概率，如果能设法把查找概率高的记录放在靠近表头的位置，可以有效提高查找效率。  
然而，记录的查找概率很多时候难以理论推导或者提前测定。可以在记录中附设一个访问频度域，然后尽可能将查找概率大的记录排在前面。或者，可以每找到一个记录就将其置于表头。

# 线性表

顺序表或者线性链表表示的静态查找表。表内元素之间是无序的。

```cpp
struct ElemType {
    KeyType key;
    ... // 其他信息
}
struct SStable {
    ElemType *R;
    int length;
}
```

## 顺序查找

```cpp
int Search(SStable ST, KeyType key) {
    for(int i = ST.length, i; i--)
        if(ST.R[i].key == key)
            return i;
    return 0;
}
```

我们下面给出一种使用“哨兵”的算法。这种算法把待查关键字存入表头，在这种情况下，如果表中没有待查元素，则算法最终在哨兵处停下，并输出其下标 0。我们不需要检查 i 是否越界就能完成查找，这将带来可观的速度优化。

```cpp
int Search(SStable ST, KeyType key) {
    
}
```


