# 排序

排序是将一组杂乱无章的数据按某种规律顺次排列，即将无序序列排成一个有序序列。

如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个数据域来言的。

## 排序方式的分类

按存储介质分类
- 内部排序：数据量不大，数据在内存，无需内外存交换顺序。
- 外部排序：数据量较大，数据在外存，常见为文件排序。外部排序需要将数据分批调入内存来进行排序，再将排序结果放入外存，要更为复杂。

按 CPU 个数分类
- 串行排序：单处理器，同一时刻处理一对元素。
- 并行排序：多处理器，同一时刻处理多对元素。

按操作分类
- 比较排序：用比较的方法排序。
- 基数排序：不比较元素的大小，仅仅根据元素本身取值确定序。

按辅助空间分类
- 原地排序：算法使用辅助空间的空间复杂度为 $O(1)$。
- 非原地排序：算法使用辅助空间的空间复杂度不为 $O(1)$。

按稳定性分类
- 稳定排序：使任何数值相等的元素，排序前后相对顺序不变。
- 非稳定排序：数值相等的元素，排序前后相对顺序可能改变。

按自然性分类
- 自然排序：输入数据越有序，排序的速度就越快。
- 非自然排序：不满足自然排序。

# 插入排序

在有序序列中插入一个元素，保持序列有序。

插入排序可以直接插入，可以二分定位插入，也可以缩小增量进行希尔排序。

## 顺序插入排序

```cpp
void InsertSort(vector<int> &v) {
    int i, j, x;
    for(i = 1; i < v.size(); i++){
        x = v[i];
        for(j = i - 1; j >= 0 && x < v[j]; j--)
            v[j + 1] = v[j];
        v[j + 1] = x;
    }
}
```

对于不使用 0 号下标的实现，可使用“哨兵”。它减少了一次逻辑运算，可以提高效率。

```cpp \\ 不使用 0 号下标
void InsertSort(vector<int> &v) {
    int i, j;
    for(i = 2; i < v.size(); i++){
        v[0] = v[i];
        for(j = i - 1; v[j] > v[0]; j--)
            v[j + 1] = v[j];
        v[j + 1] = x;
    }
}
```

在最好情况下，键在序列中顺序。需要比较的次数是 $n-1$，需要移动的次数是 $0$。  
在最坏情况下，键在序列中逆序。需要比较的次数是 $\frac{(n-1)(n+2)}2$，需要移动的次数是 $\frac{(n-1)(n+4)}2$。时间复杂度是 $O(n^2)$。  
在平均情况下，需要比较的次数是 $\frac{(n-1)(n+2)}4$，需要移动的次数是 $\frac{(n-1)(n+6)}4$。时间复杂度是 $O(n^2)$，耗时约为最坏情况下的一半。  

## 折半插入排序



```cpp \\ 不使用 0 号下标
void BinaryInsertSort(vector<int> &v) {
    int i, j;
    for(i = 2; i < v.size(); i++) {
        v[0] = v[i];
        int lo = 1, hi = i - 1, mid;
        while(lo <= hi) {
            mid = (lo + hi) >> 1;
            if(v[0] < v[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        for(j = i - 1; j >= hi + 1; j--)
            v[j + 1] = v[j];
        v[hi + 1] = v[0];
    }
}
```

当数据规模 n 较大时，折半插入排序的键比较次数比直接插入排序的最坏情况要好得多，但其最好情况要差。事实上当对象的初始排列已经有序或接近有序时，直接插入排序要比折半插入排序比较次数更少。  
折半插入排序的对象移动次数与直接插入排序相同。换言之，折半插入排序减少了比较次数，但没有减少移动次数。其平均性能优于直接插入排序。  
时间复杂度 $O(n^2)$，空间复杂度 $O(1)$。该排序算法稳定。

# 希尔排序

