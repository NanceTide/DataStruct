# 排序

排序是将一组杂乱无章的数据按某种规律顺次排列，即将无序序列排成一个有序序列。

如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个数据域来言的。

## 排序方式的分类

按存储介质分类
- 内部排序：数据量不大，数据在内存，无需内外存交换顺序。
- 外部排序：数据量较大，数据在外存，常见为文件排序。外部排序需要将数据分批调入内存来进行排序，再将排序结果放入外存，要更为复杂。

按 CPU 个数分类
- 串行排序：单处理器，同一时刻处理一对元素。
- 并行排序：多处理器，同一时刻处理多对元素。

按操作分类
- 比较排序：用比较的方法排序。
- 基数排序：不比较元素的大小，仅仅根据元素本身取值确定序。

按辅助空间分类
- 原地排序：算法使用辅助空间的空间复杂度为 $O(1)$。
- 非原地排序：算法使用辅助空间的空间复杂度不为 $O(1)$。

按稳定性分类
- 稳定排序：使任何数值相等的元素，排序前后相对顺序不变。
- 非稳定排序：数值相等的元素，排序前后相对顺序可能改变。

按自然性分类
- 自然排序：输入数据越有序，排序的速度就越快。
- 非自然排序：不满足自然排序。

# 插入排序

在有序序列中插入一个元素，保持序列有序。

插入排序可以直接插入，可以二分定位插入，也可以缩小增量进行希尔排序。

## 顺序插入排序

```cpp
void InsertSort(vector<int> &v) {
    int i, j, x;
    for(i = 1; i < v.size(); i++){
        x = v[i];
        for(j = i - 1; j >= 0 && x < v[j]; j--)
            v[j + 1] = v[j];
        v[j + 1] = x;
    }
}
```

对于不使用 0 号下标的实现，可使用“哨兵”。它减少了一次逻辑运算，可以提高效率。

```cpp \\ 不使用 0 号下标
void InsertSort(vector<int> &v) {
    int i, j;
    for(i = 2; i < v.size(); i++){
        v[0] = v[i];
        for(j = i - 1; v[j] > v[0]; j--)
            v[j + 1] = v[j];
        v[j + 1] = x;
    }
}
```

在最好情况下，键在序列中顺序。需要比较的次数是 $n-1$，需要移动的次数是 $0$。  
在最坏情况下，键在序列中逆序。需要比较的次数是 $\frac{(n-1)(n+2)}2$，需要移动的次数是 $\frac{(n-1)(n+4)}2$。时间复杂度是 $O(n^2)$。  
在平均情况下，需要比较的次数是 $\frac{(n-1)(n+2)}4$，需要移动的次数是 $\frac{(n-1)(n+6)}4$。时间复杂度是 $O(n^2)$，耗时约为最坏情况下的一半。  

## 折半插入排序

```cpp \\ 不使用 0 号下标
void BinaryInsertSort(vector<int> &v) {
    int i, j;
    for(i = 2; i < v.size(); i++) {
        v[0] = v[i];
        int lo = 1, hi = i - 1, mid;
        while(lo <= hi) {
            mid = (lo + hi) >> 1;
            if(v[0] < v[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        for(j = i - 1; j >= hi + 1; j--)
            v[j + 1] = v[j];
        v[hi + 1] = v[0];
    }
}
```

当数据规模 n 较大时，折半插入排序的键比较次数比直接插入排序的最坏情况要好得多，但其最好情况要差。事实上当对象的初始排列已经有序或接近有序时，直接插入排序要比折半插入排序比较次数更少。  
折半插入排序的对象移动次数与直接插入排序相同。换言之，折半插入排序减少了比较次数，但没有减少移动次数。其平均性能优于直接插入排序。  
时间复杂度 $O(n^2)$，空间复杂度 $O(1)$。该排序算法稳定。

## 希尔排序

希尔排序先将整个待排序序列分割成若干个子序列，分别进行插入排序。待整个序列中的记录基本有序，再对全体记录进行一次直接插入排序。

希尔排序是一个缩小增量排序，需要进行多遍排序。希尔排序需要指定一个增量序列，例如 $D_n>D_{n-1}>D_{n-2}>...>D_1=1$。增量序列应该是互质的、递减的，且尾项必须为 1。

然后，函数首先进行一次 $D_n$-间隔排序，然后进行一次 $D_{n-1}$-间隔排序，以此类推。最终执行一次 1-间隔排序。

```cpp
void ShellSort(vector<int> &v, vector<int> delta) {
    for(int i = 0; i < delta.size(); i++)
        ShellSort(v, delta[i]);
}
void ShellSort(vector<int> &v, int delta) {
    int i, j, x;
    for(i = delta; i < v.size(); i++) {
        if(v[i] < v[i - delta]) {
            x = v[i];
            for(j = i - delta; j >= 0 && v[0] < v[j]; j -= delta)
                v[j + delta] = v[j];
            v[j + delta] = x;
        }
    }
}
```

希尔排序算法的效率与增量序列的取值有关。如何选择最佳的增量序列目前尚未解决。该排序算法不稳定，也不适宜在链式存储结构上实现。

希尔排序的复杂度目前尚未严格证明。按一般经验来说约为 $O(n^{1.25})$。空间复杂度为 $O(1)$。

# 交换排序

交换排序是两两比较，如果发现逆序就进行交换，直到所有记录都有序为止。

```cpp
void Swap(int &a, int &b) {
    int c = a;
    a = b;
    b = c;
}
```

## 冒泡排序

```cpp
void BubbleSort(vector<int> &v) {
    for(int i = 0; i < v.size(); i++)
        for(int j = 0; j < v.size() - i - 1; j++)
            if(v[j] > v[j + 1])
                Swap(v[j], v[j + 1]);
}
```

下面是冒泡排序的一个改进版本，它借助一个 flag，初值置 false。如果在某次遍历中，发生了交换，则让 flag 置 true。如果没有发生交换，flag 保持 false。这样，如果某趟遍历过后，所有元素都有序，算法就会停止。这能提高一些效率，但收益不会特别可观。

```cpp
void BubbleSort(vector<int> &v) {
    bool flag = true;
    for(int i = 0; i < v.size() && flag; i++){
        flag = false;
        for(int j = 0; j < v.size() - i - 1; j++)
            if(v[j] > v[j + 1]) {
                Swap(v[j], v[j + 1]);
                flag = true;
            }
    }
}
```

冒泡排序的最好情况是表已经有序。需要 $n-1$ 次比较，不需要移动。此时时间复杂度为 $O(n)$。  
最坏情况是表完全倒序。需要 $\frac{n^2-n}2$ 次比较，以及 $\frac32(n^2-n)$ 次移动。注意一次交换需要三次移动。此时时间复杂度为 $O(n^2)$。  
平均来说冒泡排序具有 $O(n^2)$ 的时间复杂度和 $O(1)$ 的空间复杂度。冒泡排序是稳定的。

## 快速排序

任取一个元素作为元素中心。让所有比该元素小的元素一律前放，比该元素大的元素一律后放。现在形成了左右两个子表。如果子表的长度大于 1，则对子表使用快速排序。到最后，每个子表只剩一个元素。

```cpp
int Partition(vector<int> &v, int lo, int hi) {
    int pivot = v[lo];
    while(lo < hi) {
        while(pivot <= v[hi] && lo < hi)
            hi--;
        v[lo] = v[hi];
        while(pivot >= v[lo] && lo < hi)
            lo++;
        v[hi] = v[lo];
    }
    v[lo] = pivot;
    return lo;
}
void QuickSort(vector<int> &v, int lo, int hi) {
    if(lo >= hi)
        return;
    int i = Partition(v, lo, hi);
    QuickSort(v, lo, i - 1);
    QuickSort(v, i + 1, hi);
}
```

QuickSort 方法的时间复杂度是 $O(logn)$。Partition 方法的时间复杂度是 $O(n)$。平均来说快速排序具有 $O(nlogn)$ 的时间复杂度，具有我们讨论的所有内排序方法中最好的效率。但在最坏情况下，时间复杂度为 $O(n^2)$。  
快速排序需要使用递归，需要递归调用栈的支持。即使不用递归，也要使用用户栈。平均来说快速排序具有 $O(logn)$ 的空间复杂度，且在最坏情况下可达 $O(n)$。   
快速排序不稳定，也不是自然排序方法。当待排对象完全有序时，快速排序遇到最坏情况，退化为没有改进措施的冒泡排序。

# 选择排序

选择排序是指从待排对象中选出最小或最大元素放在最终位置。

## 简单选择排序

```cpp
void SelectionSort(vector<int> &v) {
    for(int i = 0; i < v.size() - 1; i++) {
        int minIndex = i;
        for(int j = i + 1; j < v.size(); j++)
            if(v[j] < v[minIndex])
                minIndex = j;
        Swap(v[minIndex], v[i]);
    }
}
```

在最好情况下，待排对象完全有序，需要 $0$ 次移动。在最坏情况下，待排对象反向有序，需要 $3(n-1)$ 次移动。无论何种情况，该算法需要比较的次数相同，为 $\frac{n}{2}(n-1)$。  
在最好情况、最坏情况以及平均情况下，该算法时间复杂度都为 $O(n^2)$，空间复杂度为 $O(1)$。   
简单选择排序不稳定。

## 堆排序

堆是一个完全二叉树，在该树中，任何一非叶子节点均小于（或大于）它的孩子结点。  
或者，堆是满足下列条件的线性表：  
$\begin{cases} a_i \le a_{2i} \\ 
a_i \le a_{2i+1} \end{cases}$ $(i \ge 1)$
或
$\begin{cases} a_i \ge a_{2i} \\ 
a_i \ge a_{2i+1} \end{cases}$ $(i \ge 1)$

称满足该要求的、根更小的完全二叉树为小根堆。满足该要求的、根更大的完全二叉树为大根堆。

在输出堆顶的最值后，使得剩余元素的序列重新建成一个堆，再得到剩余元素的最大值……如此反复，便可得到一个有序序列。这就是堆排序。

### 堆的调整

小根堆
1. 输出堆顶元素之后，以堆中最后一个元素替代之。
2. 将根节点值与左、右子树的根结点值进行比较，并与其中小者进行交换。
3. 重复上述操作，直至叶子结点。这将得到一个新的堆，称这个从堆顶至叶子的调整过程为筛选。

对于一个无序序列，反复筛选即得到一个堆。

### 堆的建立

显然，一个单结点的二叉树是堆；且在完全二叉树中，所有以叶子结点为根的子树是堆。

选用线性表来存储树 $(i \ge 0)$。我们从最后一个非叶子结点 $(i = \frac{n}{2})$ 开始，将以该结点为根的二叉树调整成堆，然后调整上一个结点，直至调整到整个树的根结点 $(i = 1)$。

# 归并排序

归并排序是将两个或两个以上的有序子序列归并成一个有序序列。

# 基数排序

TODO: 末尾的几种排序方式