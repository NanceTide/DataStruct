Status SortedSqListInsert(SqList &L, ElemType elem) { // 2.11
    if(L.length + 1 > L.size)
        return ERROR;
    i = 0; j = L.length;
    for(; L.elem[i] < elem; ++i);
    for(; i < j; --j)
        elem[j] = elem[j - 1];        
    elem[i] = elem;
    return OK;
}

int SqListCmp(SqList L0, SqList L1) { // 2.12
    i = 0;
    while(1) {
        if(i >= L1.length - 1 && i < L0.length - 1) {
            return -1;
        }
        else if(i >= L0.length - 1 && i < L1.length - 1) {
            return 1;
        }
        else if(i >= L0.length - 1 && i >= L1.length - 1) {
            return 0;
        }

        if(L0.elem[i] == L1.elem[i]) {
            ++i;
            continue;
        }
        else if(L0.elem[i] < L1.elem[i]) {
            return -1;
        }
        else if(L0.elem[i] > L1.elem[i]) {
            return 1;
        }
    }
}

LinkNode* LinkListLocate(LinkList L, ElemType elem) { // 2.13
    p = L->next;
    while(p->data != elem && p)
        p = p->next;
    return p;
}

int LinkListLength(LinkList L) { // 2.14
    len = 0; p = L->next;
    while(p) {
        ++len;
        p = p->next;
    }
    return len;
}

Status LinkListConncet(LinkList ha, LinkList hb, LinkList &hc) { // 2.15
    pa = ha->next;
    pc = hc;
    while(pa) {
        pc->next = (LinkNode*) malloc(sizeof(LinkNode));
        if(!pc->next)
            return ERROR;
        pc = pc->next;
        pc->data = pa->data;
        pa = pa->next;
    }
    pb = hb->next;
    while(pb) {
        pc->next = (LinkNode*) malloc(sizeof(LinkNode));
        if(!pc->next)
            return ERROR;
        pc = pc->next;
        pc->data = pb->data;
        pc = pc->next;
    }
    pc->next = nullptr;
    return OK;
}

Status SortedLinkListDelBetween(LinkList &L, ElemType mink, ElemType maxk) { // 2.19
    pa = L;
    lPtr = nullptr; rPtr = nullptr;
    while(pa->next) {
        if(pa->next->data > mink) {
            lPtr = pa;
            break;
        }
        pa = pa->next;
    }
    if(!(pa->next))
        return OK;
    while(pa->next) {
        if(pa->next->data < maxk) {
            rPtr = pa;
            break;
        }
        pa = pa->next;
    }
    if(!(pa->next))
        rPtr = pa;
    tmpPtr = lPtr->next;
    lPtr->next = rPtr->next;
    while(tmpPtr != rPtr->next) {
        tmpNextPtr = tmpPtr->next;
        free(tmpPtr);
        tmpPtr = tmpNextPtr;
    }
    return OK;
}

Status SortedLinkListDelEqual(LinkList &L, ElemType value) { // 2.20
    pa = L;
    lPtr = nullptr; rPtr = nullptr;
    while(pa->next) {
        if(pa->next->data = value) {
            lPtr = pa;
            break;
        }
        pa = pa->next;
    }
    if(!(pa->next))
        return OK;
    while(pa->next) {
        if(pa->next->data != value) {
            rPtr = pa;
            break;
        }
        pa = pa->next;
    }
    if(!(pa->next))
        rPtr = pa;
    tmpPtr = lPtr->next;
    lPtr->next = rPtr->next;
    while(tmpPtr != rPtr->next) {
        tmpNextPtr = tmpPtr->next;
        free(tmpPtr);
        tmpPtr = tmpNextPtr;
    }
    return OK;
}

Status SqListReverse(SqList &L) { // 2.21
    for(i = 0, j = L.length - 1; i < j; ++i, --j)
        swap(L.elem[i], L.elem[j]);
    return OK;
}

Status LinkListReverse(LinkList &L) { // 2.22
    beg = L->next; end = beg->next;
    while(end) {
        beg->next = end->next;
        end->next = L->next;
        L->next = end;
        end = beg->next;
    }
    return OK;
}

Status LinkListInterlacedMerge(LinkList &A, LinkList &B, LinkList &C) { // 2.23
    C = A; pa = A->next; pb = B->next;
    curr = C->next;
    while(pa || pb) {
        if(pa)  {
            curr->next = pa;
            pa = pa->next;
            curr = curr->next;
        }
        if(pb) {
            curr->next = pb;
            pb = pb->next;
            curr = curr->next;
        }
    }
    return OK;
}

Status SortedLinkListReverseMerge(LinkList &A, LinkList &B, LinkList &C) { // 2.24
    C = A; pA = A->next; pB = B->next; pC = C;
    while(pA || pB) {
        if(pA->data < pB->data || !pB) {
            end = pA;
            beg = C->next;
            C->next = end;
            pA = pA->next;
            end->next = beg;
        }
        else {
            end = pB;
            beg = C->next;
            C->next = end;
            pB = pB->next;
            end->next = beg;
        }
    }
    return OK;
}

Status CircleLinkListDelPreNode(CircleLinkList &L) { // 2.31
    p = L->next;
    while(p->next->next != L->next)
        p = p->next;
    free(p->next);
    p->next = L->next;
    return OK;
}

Status DuCircleLinkListPreInit(DuCircleLinkList &L) { // 2.32
    beg = L->next; end = beg->next->next;
    while(!(end->pre)) {
        end->pre = beg;
        end = end->next;
        beg = beg->next;
    }
    return OK;
}

Status LinkListDivide(LinkList &L, CircleLinkList &A, CircleLinkList &B, CircleLinkList &C) { // 2.33
    p = L->next; pA = A; pB = B; pC = C;
    while(p) {
        if(isalpha(p->data)) {
            pA->next = p;
            pA = pA->next;
        }
        else if(isdigit(p->data)) {
            pB->next = p;
            pB = pB->next;
        }
        else{
            pC->next = p;
            pC = pC->next;
        }
    }
    pA->next = A->next;
    pB->next = B->next;
    pC->next = C->next;
    return OK;
}

Status PolynomialDerivative(Polynomial &L) { // 2.41
    p = L->next;
    if(!p->data.exp)
    {
        L->next = p->next;
        p = p->next;
    }
    while(p != L)
    {
        p->data.coef *= p->data.exp--;
        p = p->next;
    }
    return OK;
}

Status PolynomialDivide(Polynomial &L) { // 2.42
    p = L->next;
    A = (PolyNode *)malloc(sizeof(PolyNode));
    B = (PolyNode *)malloc(sizeof(PolyNode));
    pa = A;
    pb = B;
    while (p != L)
    {
        if (p->data.exp != 2 * (p->data.exp / 2))
        {
            pa->next = p;
            pa = p;
        }
        else
        {
            pb->next = p;
            pb = p;
        }
        p = p->next;
    }
    pa->next = A;
    pb->next = B;
    return OK;
}