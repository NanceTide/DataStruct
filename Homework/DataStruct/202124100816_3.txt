输出结果： stack // 3.3

逆置栈中的元素。 // 3.4
如果栈中存在元素e，则将其删除。 

任意元素之前的所有S元素个数大于等于X元素个数。 // 3.5
证明：设两个合法序列为：
T1 = S……X……S……
T2 = S……X……X……
假定前 n 个操作都相同，从第 n+1 个操作开始，为序列不同的起始操作点。由于前 n 个操作相同，故此时两个栈（不妨为栈 A、B）的存储情况完全相同，假设此时栈顶元素均为 a。
第 n+1 个操作不同，不妨 T1 的第 n+1 个操作为 S，T2的第 n+1 个操作为 X。T1 为入栈操作，假设将 b 压栈，则 T1 的输出顺序一定是先 b 后 a；而 T2 将 a 退栈，则其输出顺序一定是先a后b。两者不同，则两个不同的合法栈操作序列的输出元素的序列一定不同。

void ditui(int n) { // 3.9
    if(i > 1) {
        printf(i);
        ditui(i - 1);
    }
}

void test(int &sum) { // 3.10
    int x;
    scanf(x);
    while(x)
        Push(S, x);
    sum = 0;
    printf(sum);
    while(Pop(S, x)) {
        sum += x;
        printf(sum);
    }
}

栈和队列本质都是线性表。 // 3.11
栈只能在其顶部进行插入和删除，队列只能在一段插入，另一端进行删除。

输出结果： char // 3.12

逆置队列中的元素。 // 3.13

4 1 3 2 // 3.14
4 2 1 3
4 2 3 1