4.1
空字符串为"\0"。空格符串有很多，可以为" \0"。
空字符串只有末尾的'\0'，长度为0。空格符串只含有空格字符和末尾的'\0'，长度为空格的个数。

4.3
StrLength(s) == 14;
StrLength(t) == 4;
SubString(s, 8, 7) == 'STUDENT';
SubString(t, 2, 1) == 'O';
Index(s, 'A') == 3;
Index(s, t) == 0;
Replace(s, 'STUDENT', q) == 'I AM A WORKER';
Concat(SubString(s, 6, 2), Concat(t, SubString(s, 7, 8))) == 'A GOOD STDENT';

4.4
s == 'THIS SAMOLE IS';
t == 'A GOOD';
v == 'THIS SAMPLE IS A GOOD ONE';
StrLength(s) == 14;
Index(v, g) == 3;
Index(u, g) == 0;

4.5
t='THESE ARE BOOKS', v='YXY', u='XWXWXW'

4.6
s0 = SubString(s, 1, 2);
s1 = SubString(s, 6, 1);
s2 = SubString(s, 4, 2);
s3 = SubString(s, 7, 1);
s4 = SubString(s, 3, 1);
Concat(ans, s0, s1);
Concat(ans, ans, s2);
Concat(ans, ans, s3);
Concat(ans, ans, s4);

4.7
s_next[] = {0, 1, 2, 3};
s_nextval[] = {0, 0, 0, 3};
t_next[] = {0, 1, 1, 1, 2, 3, 2};
t_nextval[] = {0, 1, 1, 0, 1, 3, 2};
u_next[] = {0, 1, 1, 1, 2, 2, 3, 1, 2, 3, 4, 5, 3, 2, 2, 1, 1, 2, 1, 1};
u_nextval[] = {0, 1, 1, 0, 2, 1, 3, 0, 1, 1, 0, 5, 3, 2, 2, 1, 0, 2, 1, 0};

4.8
nextval[] = {0, 1, 0, 2, 1, 0, 1, 0, 4, 0};

ADBADABBAABADABBADADA
ADABBADADA
  ^
ADBADABBAABADABBADADA
   ADABBADADA
         ^
ADBADABBAABADABBADADA
         ADABBADADA
          ^
ADBADABBAABADABBADADA
           ADABBADADA
                     ^

4.10
Status StringReverse(String &s0, String s1) {
    StrAssign(s0, "");
    s0[0] = s1[0];
    for(i = s1[0], j = 1; i > 0; i--, j++)
        s0[j] = s1[i];
    s0[j] = '\0';
}

4.12
Status Replace(String &S, String T, String V) {
    for(n = 0, i = 1; i <= Strlen(S) - Strlen(T) + 1; i++)
        if(!StrCompare(SubString(S, i, Strlen(T)), T)) {
            StrAssign(head, SubString(S, 1, i - 1));
            StrAssign(tail, SubString(S, i + Strlen(T), Strlen(S) - i - Strlen(T) + 1));
            StrAssign(S, Concat(head, V));
            StrAssign(S, Concat(S, tail));
            i += Strlen(V);
            n++;
    }
  return n;
}

4.17
int String_Replace(Stringtype &S, Stringtype T, Stringtype V) {
    for (n = 0, i = 1; i <= S[0] - T[0] + 1; i++) {
        for (j = i, k = 1; T[k] && S[j] == T[k]; j++, k++);
        if (k > T[0]) {
            if (T[0] == V[0])
                for (l = 1; l <= T[0]; l++)
                    S[i + l - 1] = V[l];
            else if (T[0] < V[0]) {
                for (l = S[0]; l >= i + T[0]; l--)
                    S[l + V[0] - T[0]] = S[l];
                for (l = 1; l <= V[0]; l++)
                    S[i + l - 1] = V[l];
            }
            else {
                for (l = i + V[0]; l <= S[0] + V[0] - T[0]; l++)
                    S[l] = S[l - V[0] + T[0]];
                for (l = 1; l <= V[0]; l++)
                    S[i + l - 1] = V[l];
            }
            S[0] = S[0] - T[0] + V[0];
            i += V[0];
            n++;
        }
    }
    return n;
}

4.21
Status StrAssign(String *S, char *chars) {
	len = strlen(chars);
	InitList(S);
	for (i = 1, p = *S; i <= len; i++) {
		s = (String)malloc(sizeof(strNode));
		if (!s)
			exit(OVERFLOW);
		s->data = chars[i - 1];
		s->next = p->next;
		p->next = s;
		p = p->next;
	}

	return OK;
}

Status StrCopy(String *S, String T) {
	if (!T)
		return ERROR;
	InitList(S);
	for (r = *S, p = T->next; p; p = p->next) {
		s = (String)malloc(sizeof(strNode));
		if (!s)
			exit(OVERFLOW);
		s->data = p->data;
		s->next = r->next;
		r->next = s;
		r = r->next;
	}
	return OK;
}


int StrCompare(String S, String T) {
	if (S && T) {
		p = S->next;
		q = T->next;
		while (p && q) {
			if (p->data != q->data)
				return p->data - q->data;
			p = p->next;
			q = q->next;
		}
		return ListLength_L(S) - ListLength_L(T);
	}
}

int StrLength(String S) {
	return ListLength(S);
}

Status Concat(String *R, String S, String T) {
	if (!S || !T)
		return ERROR;
	InitList(R);
	for (r = *R, p = S->next; p; p = p->next) {
		s = (String)malloc(sizeof(strNode));
		if (!s)
			exit(OVERFLOW);
		s->data = p->data;
		s->next = r->next;
		r->next = s;
		r = r->next;
	}
	for (p = T->next; p; p = p->next) {
		s = (String)malloc(sizeof(strNode));
		if (!s)
			exit(OVERFLOW);
		s->data = p->data;
		s->next = r->next;
		r->next = s;
		r = r->next;
	}
}

Status SubString(String *Sub, String S, int pos, int len) {
	sl = StrLength(S);
	if (!S || pos < 1 || pos > sl || len < 0 || pos + len - 1 > sl)
		return ERROR;
	InitList_L(Sub);
	for (i = 1, p = S->next; i < pos; i++, p = p->next)
		;
	for (i = 1, r = *Sub; i <= len; i++, p = p->next) {
		s = (String)malloc(sizeof(strNode));
		if (!s)
			exit(OVERFLOW);
		s->data = p->data;
		s->next = r->next;
		r->next = s;
		r = r->next;
	}
	return OK;
}

void StrPrint(String S) {
	String p;
	for (p = S->next; p; p = p->next)
		printf("%c", p->data);
}

4.24
void HStringConcat(HString s1,HString s2,HString &t) {
    if(t.ch)
        free(t.ch);
        t.ch = malloc((s1.length + s2.length) * sizeof(char));
        for(i = 1; i <= s1.length; i++)
            t.ch[i - 1] = s1.ch[i - 1];
        for(j = 1; j <= s2.length; j++, i++)
            t.ch[i - 1] = s2.ch[j - 1];
    t.length = s1.length + s2.length;
}


4.25
int HStringReplace(HString &S, HString T, HString V) {
    for (n = 0, i = 0; i <= S.length - T.length; i++) {
        for (j = i, k = 0; k < T.length && S.ch[j] == T.ch[k]; j++, k++);
        if (k == T.length) {
            if (T.length == V.length)
                for (l = 1; l <= T.length; l++)
                    S.ch[i + l - 1] = V.ch[l - 1];
            else if (T.length < V.length) {
                for (l = S.length - 1; l >= i + T.length; l--)
                    S.ch[l + V.length - T.length] = S.ch[l];
                for (l = 0; l < V.length; l++)
                    S[i + l] = V[l];
            }
            else {
                for (l = i + V.length; l < S.length + V.length - T.length; l++)
                    S.ch[l] = S.ch[l - V.length + T.length];
                for (l = 0; l < V.length; l++)
                    S[i + l] = V[l];
            }
            S.length += V.length - T.length;
            i += V.length;
            n++;
        }
    }
    return n;
}

4.30
Status Func4_30(SString S, SString Sub, int *pos){
	if (S[0] < 2)
		return ERROR;
	Sub[0] = 0;
	for (k = 1; k < S[0]; k++) {
		i = k;
		j = k + 1;
		while (j <= S[0] && S[i] != S[j])
			j++;
		if (j <= S[0]) {
			start = i;
			end = j;
			len = 0;
			while (j <= S[0] && S[i] == S[j]) {
				i++;
				j++;
				len++;
			}
			if (len > Sub[0] && start + len - 1 >= end - 1) {
				*pos = start;
				SubString(Sub, S, start, len);
			}
		}
	}
	if (Sub[0])
		return OK;
	else
		return ERROR;
}
复杂度：O(Strlen(S)^2)