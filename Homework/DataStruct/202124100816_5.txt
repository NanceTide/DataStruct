5.5 ->
f1(i) = (n + 1/2)i - (1/2) * i^2
f2(j) = j
c = -(n + 1)

5.6 ->
u = i - j + 1
v = j - 1

5.7 ->
k = 3(i - 1) - 1 + (2 - (i - j)) - 1 = 2i + j - 3

5.8 ->
k = 2i - j % 2 - 1.

5.18 ->
Status 5_18(Array A, int k) {
    n = Length(A);
    p = k % n;
    if(p <= 0)
        return ERROR;
    Reverse(A, 0, n-1);
    Reverse(A, 0, p-1);
    Reverse(A, p, n-1);
    return OK;
}

Status Reverse(Array A, int begin, int end) {
    if(begin < 0 || end > Length(A)-1 || begin >= end)
        return ERROR;
    for(i = 0; i < (end - begin + 1) / 2; i++) {
        Value(A, e1, begin + i);
        Value(A, e2, end - i);
        Assign(A, e2, begin + i);
        Assign(A, e1, end - i);
    }
    return OK;
}

5.19 ->
void 5_19(Array A) {
    row = A.bounds[0];
    col = A.bounds[1];
    Min = (Elem*) malloc(row * col * sizeof(Elem));
    Max = (ElemType*) malloc(col * sizeof(ElemType));
    for(j = 0; j < col; j++)
        Max[j] = INT_MIN;
    total = 0;
    for(i = 0; i < row; i++) {
        min = INT_MAX;
        for(j = 0; j < col; j++) {
            Value(A, e, i, j);
            if(e > Max[j])
                Max[j] = e;
            if(e <= min) {
                if(e < min) {
                    k = total;
                    min = e;
                }
                Min[k].x = i;
                Min[k].y = j;
                Min[k].value = e;
                k++;
            }
        }
        total += (k - total);
    }
    count = 0;
    for(k = 0; k < total; k++) {
        if(Max[Min[k].y] == Min[k].value) {
            printf("(%d, %d) -> %d", ++count, Min[k].x, Min[k].y, Min[k].value);
        }
    }
}

5.21 ->
Status AddSMatrix(TSMatrix M, TSMatrix N, TSMatrix Q) {
    if(M.mu != N.mu || M.nu != N.nu)
        return ERROR;
    Q.mu = M.mu;
    Q.nu = M.nu;
    Q.tu = 0;
    m = n = k = 1;
    while(m <= M.tu && n <= N.tu) {
        if(M.data[m].i < N.data[n].i) {
            Q.data[k] = M.data[m];
            m++;
        } else if(M.data[m].i > N.data[n].i) {
            Q.data[k] = N.data[n];
            n++;
        } else {
            if(M.data[m].j < N.data[n].j) {
                Q.data[k] = M.data[m];
                m++;
            } else if(M.data[m].j > N.data[n].j) {
                Q.data[k] = N.data[n];
                n++;
            } else {
                if((M.data[m].e + N.data[n].e) == 0) {
                    m++;
                    n++;
                    continue;
                } else {
                    Q.data[k].i = M.data[m].i;
                    Q.data[k].j = M.data[m].j;
                    Q.data[k].e = M.data[m].e + N.data[n].e;
                    m++;
                    n++;
                }
            }
        }
        k++;
        Q.tu++;
    }
    while(m <= M.tu) {
        Q.data[k] = M.data[m];
        m++;
        k++;
        Q.tu++;
    }
    while(n <= N.tu) {
        Q.data[k] = N.data[n];
        n++;
        k++;
        Q.tu++;
    }
    return OK;
}