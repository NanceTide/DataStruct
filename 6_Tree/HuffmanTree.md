# 哈夫曼树的定义

现试图用 N 个带权的叶子结点构造一棵二叉树。一棵带权路径长度最小的二叉树被称为最优二叉树或哈夫曼树。

> 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。例如图中从根结点到结点 a 之间的通路就是一条路径。  

> 路径长度：两节点连通最短经过的结点数。例如从根结点到第 i 层任意结点的路径长度为 i - 1。图中从根结点到结点 c 的路径长度为 3。  

> 树的路径长度(TL)：从树根到每一个结点的路径长度之和。
> - 结点相同数目的二叉树中，完全二叉树的路径长度最短。但路径长度最短的二叉树未必是完全二叉树。
>   - 这里的最短是在度相同的树中比较得到的。不同度的树比较路径长度没有意义。

> 结点的权：给每结点赋予一个有某种意义的值，称为这个结点的权。例如图中结点 a 的权为 7，结点 b 的权为 5。  

> 结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。例如图中结点 b 的带权路径长度为 2 * 5 = 10。

> 树的带权路径长度(WPL)：树中所有叶子结点的带权路径长度之和。例如图中树的带权路径长度为 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3。

![](markdown/6-C-1.png)

- 哈夫曼树是带权路径长度最短的树。
- 满二叉树未必是哈夫曼树。
- 具有相同带权结点的哈夫曼树未必唯一。
- 哈夫曼树的结点度为 0 或 2，没有度为 1 的结点。
- 包含 n 个叶子结点的哈夫曼树中共有 2n - 1 个结点。
- 包含 n 棵树的森林要经过 n - 1 次合并才能形成哈夫曼树，共产生 n - 1 个新结点。

这里采用顺序存储结构来存取哈夫曼树。

```cpp
typedef struct HTNode {
    int weight;
    int parent, lchild, rchild;
}*HuffmanTree;
```

# 哈夫曼树的构造

对于给定的有各自权值的 n 个结点，可按如下步骤构造哈夫曼树。
1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和。
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n – 2 个权值的行列中。
3. 重复 1 和 2 ，直到所有结点构建成一棵二叉树为止，这棵树就是哈夫曼树。

重复一遍，哈夫曼树具有如下性质。这对构造至关重要。  
- 包含 n 个叶子结点的哈夫曼树中共有 2n - 1 个结点。  
- 包含 n 棵树的森林要经过 n - 1 次合并才能形成哈夫曼树，共产生 n - 1 个新结点。  

下面假定采用顺序存储结构实现哈夫曼树。  

首先实现 Select()。该函数查找权重最小的两个结点。  
函数传入四个参数，第一个参数是 HT 数组，其中存放着哈夫曼树的叶子结点。这些结点的权重已经给出。第二个参数 end 表示函数要从 HT[1] 到 HT[end] 的所有结点选出两个最小的结点。第三、第四个参数是整型，表示最小的两个结点的索引。  
该函数声明的变量 min1 是最小的数，min2 是次小的数。  
该函数从数组起始位置开始，首先找到两个无父结点的结点（无双亲结点说明还未被构建成树，无双亲即 parent 不为 0），然后与后续无双亲结点的结点依次比较。
- 如果比两个结点中较小的结点还小，保留该结点，删除原来较大的结点。
- 如果介于两个结点权重值之间，替换原来较大的结点。

```cpp
void Select(HuffmanTree HT, int end, int &s1, int &s2) {
    int min1, min2, i;
    
    for(i = 1; HT[i].parent != 0 && i <= end; i++);
    s1 = i; min1 = HT[i].weight;

    for(i++; HT[i].parent != 0 && i <= end; i++);
    s2 = i; min2 = HT[i].weight;

    if(min1 > min2) {
        swap(min1, min2);
        swap(s1, s2);
    }

    for(i++; i <= end; i++) {
        if(HT[i].parent != 0)
            continue;
        if(HT[i].weight < min1) {
            min2 = HT[i].weight;
            s2 = i;
            swap(min1, min2);
            swap(s1, s2);
        } else if (HT[i].weight < min2 && HT[i].weight >= min1) {
            min2 = HT[i].weight;
            s2 = i;
        }
    }
}
```

接着实现哈夫曼树的生成函数。已经提到，有 n 个叶子结点的哈夫曼树必定总共有 2 * n - 1 个结点。又由于不使用第零个结点，所以申请 2 * n 个空间。  
当 n <= 1，返回一棵空树。接着申请空间。然后，从数组中读入 n 个结点的权重，将其孩子、双亲都设为零。还需将剩下的 n - 1 个结点的双亲设为 0，否则 Select() 无从知道该结点是否被使用过。最后，设计一个循环。从 i = n + 1 开始，在前 i 个结点中选出双亲不存在的、权重最小的两个结点，令其成为 HT[i] 的左右孩子，它们的权重之和是 HT[i] 的权重。

```cpp
void CreateHuffmanTree(HuffmanTree &HT, int *arr, int n) {
    if(n <= 1)
        return;
    int m = 2 * n - 1;
    HT = (HuffmanTree) malloc ((m + 1) * sizeof(HTNode));
    for(int i = 1; i <= n; i++) {
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
        HT[i].weight = arr[i - 1];
    }
    for(int i = n + 1; i <= m; i++)
        HT[i].parent = 0;
    for(int i = n + 1; i <= m; i++) {
        int s1, s2;
        Select(HT, i - 1, s1, s2);
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```

# 哈夫曼编码

哈夫曼编码是一种可变字长编码，它完全依据字符出现的概率来构造异字头的平均长度最短的码字。

在传输字符信息时，需要令字符与二进制编码一一对应。

使用频繁的是定长编码，例如
> |字符|A|B|C|D|
> |:-:|:-:|:-:|:-:|:-:|
> |编码|00|01|10|11|
> 
> ABACCDA -> 00010010101100  
> 00010010101100 -> ABACCDA

变长编码容易引起歧义。观察下列例子
> |字符|A|B|C|D|
> |:-:|:-:|:-:|:-:|:-:|
> |编码|0|00|1|01|
>
> ABACCDA -> 000011010  
> 000011010 -> ?
这个编码的解释不止一种，因此这种编码方式是不合适的。如何解决这个问题？

我们指出可以这样构造一种编码方式，在该变长编码对应规则中，任何一字符的编码都不是其他字符编码的前缀。这种编码不会引起歧义，被称为前缀编码。哈夫曼编码就是一种前缀编码。

1. 统计字符集中每个字符在电文中的出现平均概率。
2. 利用哈夫曼树的特点，权越大的叶子离根越近。将每个字符的概率值作为权值，构造哈夫曼树。概率越大的结点路径应该越短。
3. 在哈夫曼树的左分支标 0，右分支标 1。把从根到每个叶子的路径上的标号连接起来，来作为该叶子代表的字符的编码。

例如，字符集 {C, A, S, T, ;} 的频率分别为 {2, 4, 2, 3, 3}。创建哈夫曼树  
![](/6_Tree/markdown/6-C-2.png) 

> |字符|T|;|A|C|S|
> |:-:|:-:|:-:|:-:|:-:|:-:|
> |编码|00|01|10|110|111|

每个字符的编码这样确定：从根节点开始前往指定字符，每经过左分支，记 0，每经过右分支，记 1。一路上路过的所有分支记录的字符，就是字符编码。

哈夫曼编码很好地利用了二叉树的性质和哈夫曼树的性质。  
每个字符的编码都对应二叉树的一个叶子结点，而叶子节点没有孩子，没有任何一叶子结点是另一叶子结点的祖先。这意味着任何一字符的编码都不是其他字符编码的前缀。哈夫曼编码一定是前缀编码。  
哈夫曼树的带权路径长度最短，故字符编码的总长度最短。

哈夫曼编码是最优前缀码。

思考如何实现哈夫曼编码。  
- 创建哈夫曼树，树中有 n 个叶子结点。
- 为 HC 分配足够的空间。需分配 n + 1 个。
- 声明一个长 n 的字符串 cd，用于缓存当前的编码字符串。置 cd[n - 1] = '\0'。
- 从叶子结点 HT[1] 开始遍历所有 n 个叶子结点。下设当前操作的叶子节点是 HT[i]。
  - 维护整型 start，它是编码串 cd 中，现在正操作的字符的索引。它被初始化为 n - 1，这是 cd 的最后一位，即 '\0'。当循环遍历完毕时，start 指向的索引正好是编码串的开始位置。
  - 维护整形 prev = i，curr = HT[i].parent。curr 是函数目前处理的结点的索引，prev 是函数上一次处理的结点的索引。当 curr 不为 0 时，进行如下循环。
    - 令 start 自减。
    - 如果 curr 指向的结点的 lchild 与 prev 相同，记 cd[start] 为 0。
    - 如果 curr 指向的结点的 rchild 与 prev 相同，记 cd[start] 为 1。
    - 令 prev = curr，curr = HT[curr].parent。
  - 为 HC[i] 声明足够的空间。需要声明 n - start 个空间。
  - 把编码串 &cd[start] 拷贝到 HC[i]。
- 释放 cd。

---

- HC 需要分配 n + 1 个空间，因为没有使用下标为 0 的位置。
- 将缓存的编码字符串 cd 长度设为 n，是因为除了占一位置的 '\0' 外，含 n 个叶子结点的树层数最多为 n，编码长度最多为 n - 1 位。
- HC[i] 需要声明 n - start 个空间。因为 '\0' 的下标为 n - 1, 编码串首字符的下标为 start，字符串需要的空间总共是 n - 1 - start + 1 = n - start。

```cpp
void HuffmanCoding(HuffmanTree HT, HuffmanCode &HC, int n) {
    HC = (HuffmanCode) malloc ((n + 1) * sizeof(char*));
    char *cd = (char*) malloc (n * sizeof(char));
    for(int i = 1; i <= n; i++) {
        int start = n - 1;
        for(int prev = i, curr = HT[i].parent; curr != 0; prev = curr, curr = HT[curr].parent) {
            start--;
            if(HT[curr].lchild == prev)
                cd[start] = '0';
            else
                cd[start] = '1';
        }
        HC[i] = (char*) malloc ((n - start) * sizeof(char));
        strcpy(HC[i], &cd[start]);
    }
    free(cd);
}
````

# 哈夫曼编码的解码

